<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Rolezinho">
<meta name="format-detection" content="telephone=no">
<link rel="mask-icon" href="icons/maskable-icon.png" color="#000000">
<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512.png">
<meta name="theme-color" content="#000000">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<link rel="apple-touch-icon" sizes="512x512" href="icons/icon-512.png">
<title>Fotos no Mapa</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="manifest" href="manifest.json">
<script>
  if ('serviceWorker' in navigator && (location.protocol === 'https:' || location.hostname === 'localhost')) {
    navigator.serviceWorker.register('/sw.js').catch(err => {});
  } else {
    /* Service worker not registered (insecure or unsupported protocol). */
  }
/* --- PATCH 5.4-D3 — Keyboard Detection (evitar overlap com teclado) --- */
(function(){
  const root = document.documentElement;

  function markKeyboardOpen() {
    root.classList.add("keyboard-open");
  }
  function markKeyboardClosed() {
    root.classList.remove("keyboard-open");
  }

  // Detect focus on inputs
  document.addEventListener("focusin", (e) => {
    if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
      markKeyboardOpen();
    }
  });

  // Detect focus out
  document.addEventListener("focusout", (e) => {
    if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
      setTimeout(() => {
        if (!document.activeElement || 
            (document.activeElement.tagName !== "INPUT" && 
             document.activeElement.tagName !== "TEXTAREA")) {
          markKeyboardClosed();
        }
      }, 120);
    }
  });

  // iOS viewport change fallback
  window.visualViewport && window.visualViewport.addEventListener("resize", () => {
    if (window.visualViewport.height < window.innerHeight * 0.85) {
      markKeyboardOpen();
    } else {
      markKeyboardClosed();
    }
  });
})();
</script>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: #000;
    color: white;
    overflow-x: hidden;
    overscroll-behavior-y: none !important;
    overscroll-behavior: none !important;
  }

  html {
    height: 100%;
    overscroll-behavior: none !important;
  }

  #map {
    height: calc(100svh - 110px - env(safe-area-inset-bottom) - env(safe-area-inset-top));
    width: 100%;
    border: none;
    margin: 0;
    padding: 0;
    touch-action: pan-x pan-y !important;
    -webkit-overflow-scrolling: touch !important;
  }

  .mobile-btn {
    width: 90%;
    padding: 14px;
    font-size: 18px;
    border-radius: 12px;
    margin: 6px auto;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
  }

  #bottomBar button.mobile-btn {
    flex: 1;
    margin: 0 6px;
    height: 72px;
    font-size: 18px;
    padding: 0 10px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  @media (max-width: 600px) {
    #bottomBar button.mobile-btn {
      height: 64px;
      font-size: 16px;
    }
  }

  input, button {
    margin: 5px;
    padding: 8px 12px;
    border-radius: 5px;
    cursor: pointer;
  }

  img.thumbnail {
    width: 100px;
    border-radius: 5px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  }

  /* POPUP FIXES */
  .leaflet-popup {
    pointer-events: auto !important;
    z-index: 999999;
  }

  .leaflet-popup-content {
    pointer-events: auto !important;
  }

/* --- PATCH 5.4 — Popup Fade Refinement (C-Final) --- */
.leaflet-popup {
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 320ms ease-out,
              transform 320ms ease-out;
}
.leaflet-popup.rz-show {
  opacity: 1;
  transform: translateY(0);
}

  .leaflet-popup-content button {
    pointer-events: auto !important;
    touch-action: manipulation !important;
  }

  /* --- PATCH 5.4-C — Minimalist iOS Popup Style --- */
  .leaflet-popup-content-wrapper {
    background: rgba(0,0,0,0.72) !important;
    backdrop-filter: blur(14px) !important;
    -webkit-backdrop-filter: blur(14px) !important;
    border-radius: 16px !important;
    box-shadow: 0 8px 28px rgba(0,0,0,0.45) !important;
    border: 1px solid rgba(255,255,255,0.08) !important;
    padding: 6px 10px !important;
  }

  .leaflet-popup-tip {
    background: rgba(0,0,0,0.72) !important;
    backdrop-filter: blur(14px) !important;
    -webkit-backdrop-filter: blur(14px) !important;
    box-shadow: 0 6px 20px rgba(0,0,0,0.35) !important;
    border: 1px solid rgba(255,255,255,0.08) !important;
  }

  .leaflet-popup-content {
    color: white !important;
    font-weight: 400 !important;
    padding: 8px 4px !important;
    line-height: 1.35 !important;
  }

  .popup-nav-btn {
    background: rgba(255,255,255,0.08) !important;
    border: 1px solid rgba(255,255,255,0.12) !important;
    border-radius: 12px !important;
    padding: 10px 14px !important;
    transition: background 160ms ease, transform 160ms ease;
  }

  .popup-nav-btn:active {
    background: rgba(255,255,255,0.18) !important;
    transform: scale(0.96);
  }

  .leaflet-container {
    touch-action: manipulation !important;
  }

  /* PROFILE MODAL FIX */
  #profileModal {
    position: fixed;
    inset: 0;
    z-index: 1000000 !important;
    pointer-events: auto;
    overscroll-behavior: contain !important;
    -webkit-overflow-scrolling: touch !important;
    padding-bottom: env(safe-area-inset-bottom);
  }

  #profileModal, #profileModal * {
    pointer-events: auto !important;
  }

  body.no-scroll {
    overflow: hidden !important;
    height: 100vh !important;
    overscroll-behavior: none !important;
  }

  /* MEDIA WRAPPERS */
  .popup-media-wrapper {
    display: flex;
    justify-content: center;
    width: 100%;
  }

  .popup-media {
    max-width: 210px;
    border-radius: 12px;
  }
  /* --- PATCH 5.4-A — Micro Animations --- */
  .rz-fade {
    opacity: 0;
    animation: rzFadeIn 300ms ease forwards;
  }
  .rz-pop {
    transform: scale(0.92);
    animation: rzPop 180ms ease-out forwards;
  }
  button:active {
    transform: scale(0.96);
    transition: transform 120ms ease-out;
  }
/* --- PATCH 5.4-B3 — Progress Modal Fade + Scale + Smooth Bar --- */
.rz-progress {
  opacity: 0;
  transform: scale(0.90);
  transition: opacity 420ms cubic-bezier(0.22, 0.61, 0.36, 1),
              transform 420ms cubic-bezier(0.22, 0.61, 0.36, 1);
}
.rz-progress.rz-open {
  opacity: 1;
  transform: scale(1);
}
#progressModalBar {
  transition: width 260ms cubic-bezier(0.22, 0.61, 0.36, 1) !important;
}

  /* --- PATCH 5.4-D1 — Bottom Bar Responsiva --- */
  #bottomBar {
    transition: transform 520ms cubic-bezier(0.16, 1, 0.3, 1), height 260ms ease;
    height: 110px;
    padding-bottom: env(safe-area-inset-bottom);
    padding-top: calc(env(safe-area-inset-top) + 4px);
  }
  #bottomBar.bottom-hidden {
    transform: translateY(0) !important;
  }

  /* Landscape: bottom bar menor */
  @media (orientation: landscape) and (max-height: 480px) {
    #bottomBar {
      height: 70px !important;
    }
    #bottomBar button.mobile-btn {
      height: 52px !important;
      font-size: 14px !important;
    }
  }

  /* Dynamic Island / iPhone 14+ */
  @supports (padding-top: env(safe-area-inset-top)) {
    #bottomBar {
      padding-bottom: calc(env(safe-area-inset-bottom) + 6px);
    }
  }

  /* Fine‑tuning para evitar sobreposição com teclado */
  html.keyboard-open #bottomBar {
    transform: translateY(110%);
  }
</style>
</head>
<body style="overscroll-behavior:none;">
  <!-- GLOBAL LOADER -->
  <div id="globalLoader" style="display:none; position:fixed; inset:0; z-index:2000000; background:rgba(0,0,0,0.55); align-items:center; justify-content:center; gap:12px;">
    <div style="background:rgba(0,0,0,0.85); padding:18px 22px; border-radius:14px; display:flex; flex-direction:column; align-items:center; gap:12px;">
      <div style="width:44px; height:44px; border-radius:22px; border:4px solid rgba(255,255,255,0.08); border-top-color:white; animation:rz-spin 900ms linear infinite;"></div>
      <div id="globalLoaderText" style="font-size:15px; color:#fff; text-align:center; max-width:320px;">Carregando…</div>
    </div>
  </div>
  <style>
    @keyframes rz-spin { from{transform:rotate(0)} to{transform:rotate(360deg)} }
  </style>

  <!-- PROGRESS MODAL -->
  <div id<div id="progressModal" class="rz-modal rz-progress" style="progressModal" style="
    display:none;
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.78);
    backdrop-filter:blur(12px);
    -webkit-backdrop-filter:blur(12px);
    z-index:2000001;
    align-items:center;
    justify-content:center;
  ">
    <div style="
      background:rgba(0,0,0,0.9);
      padding:22px 26px;
      border-radius:14px;
      width:260px;
      display:flex;
      flex-direction:column;
      text-align:center;
      gap:14px;
    ">
      <div id="progressModalMsg" style="font-size:16px; font-weight:500;">Processando…</div>

      <div style="
        width:100%;
        height:8px;
        border-radius:5px;
        background:rgba(255,255,255,0.12);
        overflow:hidden;
      ">
        <div id="progressModalBar" style="
          width:0%;
          height:100%;
          background:white;
          border-radius:4px;
          transition:width 160ms ease-out;
        "></div>
      </div>

      <div id="progressModalPercent" style="font-size:13px; opacity:0.7;">
        0%
      </div>
    </div>
  </div>

<div id="onboarding" class="rz-modal rz-fade" style="position:fixed; inset:0; background:black; color:white; z-index:99999; display:flex; flex-direction:column; justify-content:center; align-items:center; gap:30px; text-align:center; padding:40px;">
  <div style="max-width:600px; width:90%; margin:0 auto; text-align:center; display:flex; flex-direction:column; align-items:center;">
    <h1 style="font-size:72px; margin-bottom:20px; width:90%; max-width:600px; text-align:center;">Bem-vindo ao App Rolezinho</h1>
    <p style="font-size:38.4px; max-width:600px; width:90%; text-align:center; line-height:1.4;">Crie mapas dos seus rolês a partir de suas fotos.</p>
    <button id="obNext1" style="padding:12px 24px; font-size:20px; border-radius:10px;">Começar</button>
    <button class="skipOnboarding" style="margin-top:10px;">Pular</button>
  </div>
</div>

<div id="onboarding2" class="rz-modal" style="display:none; position:fixed; inset:0; background:black; color:white; z-index:99999; overflow-y:auto; display:flex; flex-direction:column; justify-content:center; align-items:center; padding:40px 20px; text-align:center; gap:40px;">
  <div style="max-width:600px; width:90%; margin:0 auto; text-align:center; display:flex; flex-direction:column; align-items:center;">
    <h2 style="font-size:72px; width:90%; max-width:600px; text-align:center; margin:0 auto;">Como funciona</h2>
    <p style="font-size:38.4px; width:90%; max-width:600px; text-align:center; line-height:1.6; margin:0 auto;">
      1 - Envie suas fotos<br>
      2 - O mapa do seu rolezinho é criado automaticamente<br>
      3 - Compartilhe o seu rolezinho com sua galera
    </p>
    <button id="obNext2" style="margin-top:50px; padding:14px 28px; font-size:24px; border-radius:12px;">Continuar</button>
    <button class="skipOnboarding" style="margin-top:10px;">Pular</button>
  </div>
</div>

<div id="onboarding3" class="rz-modal" style="display:none; position:fixed; inset:0; background:black; color:white; z-index:99999; overflow-y:auto; display:flex; flex-direction:column; justify-content:center; align-items:center; padding:20px 20px; text-align:center; gap:20px; padding-bottom:60px;">
  <div style="max-width:600px; width:90%; margin:0 auto; text-align:center; display:flex; flex-direction:column; align-items:center;">
    <h2 style="font-size:48px; width:90%; max-width:600px; text-align:center;">Crie seu Perfil</h2>
    <p style="margin-top:10px; font-size:26.4px; width:90%; max-width:600px; text-align:center; line-height:1.4;">Digite seu nome e username:</p>
    <input id="onName" placeholder="Seu nome" style="margin-top:10px; padding:12px; width:90%; max-width:500px; border-radius:10px; font-size:18px;">
    <input id="onUser" placeholder="@username" style="margin-top:10px; padding:12px; width:90%; max-width:500px; border-radius:10px; font-size:18px;">
    <input id="onPhone" placeholder="Telefone" style="margin-top:10px; padding:12px; width:90%; max-width:500px; border-radius:10px; font-size:18px;">
    <input id="onEmail" placeholder="Email" style="margin-top:10px; padding:12px; width:90%; max-width:500px; border-radius:10px; font-size:18px;">
    <button id="finishOnboarding" style="margin-top:20px; padding:14px 20px; font-size:20px; border-radius:10px; width:90%; max-width:300px; align-self:center; margin-bottom:20px;">Concluir</button>
    <button class="skipOnboarding" style="margin-top:10px;">Pular</button>
  </div>
</div>

<div id="profileModal" class="rz-modal rz-fade" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.9); color:white; z-index:1000000; padding:40px 20px; overflow-y:auto; -webkit-overflow-scrolling:touch; overscroll-behavior:contain;">
  <h2>Meu Perfil</h2>
  <p><b>Nome:</b> <span id="profileName"></span></p>
  <p><b>Username:</b> <span id="profileUser"></span></p>
  <p><b>Telefone:</b> <span id="profilePhone"></span></p>
  <p><b>Email:</b> <span id="profileEmail"></span></p>
  <div style="margin-top:20px;">
    <p><b>Foto de Perfil:</b></p>
    <img id="profilePhotoPreview" src="" style="width:100px; height:100px; border-radius:50%; object-fit:cover; display:none; margin-bottom:10px;">
    <input type="file" id="profilePhotoInput" accept="image/*" style="padding:8px 12px; border-radius:6px;">
  </div>
  <h3>Meus Rolês</h3>
  <div id="profileRoles" style="margin-top:20px; max-height:60vh; overflow-y:auto; padding-right:10px;"></div>
  <button id="closeProfile" style="margin-top:20px; padding:8px 14px;">Fechar</button>
</div>

<!-- Reorder modal -->
<div id="reorderModal" class="rz-modal rz-fade" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.95); color:white; z-index:1000001; padding:20px; overflow:auto;">
  <div style="max-width:720px; margin:0 auto;">
    <h2 style="text-align:center; margin-top:8px;">Ordenar seu Rolê</h2>
    <p style="text-align:center; opacity:0.85;">Arraste as miniaturas para reordenar. A ordem padrão é cronológica.</p>
    <div id="reorderList" style="max-width:640px; margin:18px auto; display:flex; flex-direction:column; gap:12px;"></div>
    <div style="display:flex; justify-content:center; gap:12px; margin-top:20px;">
      <button id="reorderConfirm" style="padding:12px 18px; border-radius:10px;">Confirmar ordem</button>
      <button id="reorderCancel" style="padding:12px 18px; border-radius:10px; background:#333;">Cancelar</button>
    </div>
  </div>
</div>

<input 
  type="file" 
  id="upload" 
  multiple 
  accept="image/*,video/*"
  capture="environment"
  style="opacity:0; position:absolute; inset:0; width:100%; height:100%; z-index:5; pointer-events:auto;"
>
  <div id="bottomBar" class="rz-pop" style="position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  background: #000;
  padding: 12px 0;
  display: none;
  justify-content: space-between;
  align-items: center;
  z-index: 100;
  border-top: 1px solid #333;
  height: 110px;
  padding-bottom: env(safe-area-inset-bottom);">
  <button id="uploadBtn" class="mobile-btn rz-pop" style="background:#111; border:2px solid #333; position:relative; overflow:hidden;">
    <input 
      type="file" 
      id="uploadOverlay"
      multiple
      accept="image/*,video/*"
      capture="environment"
      style="position:absolute; inset:0; opacity:0; z-index:10; pointer-events:auto;"
    >
    <svg width="22" height="22" viewBox="0 0 24 24" fill="white"><path d="M12 2l4 4h-3v6h-2V6H8l4-4zm-7 14v4h14v-4h2v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4h2z"/></svg>
    Mídias
  </button>

  <button id="saveRoute" class="mobile-btn rz-pop" style="background:#111; border:2px solid #333; opacity:0.4; pointer-events:none; display:none;">
    Salvar
  </button>

  <button id="openProfile" class="mobile-btn rz-pop" style="background:#111; border:2px solid #333;">
    <svg width="22" height="22" viewBox="0 0 24 24" fill="white"><path d="M12 12c2.7 0 5-2.3 5-5s-2.3-5-5-5-5 2.3-5 5 2.3 5 5 5zm0 2c-3.3 0-10 1.7-10 5v3h20v-3c0-3.3-6.7-5-10-5z"/></svg>
    Perfil
  </button>

  <button id="shareOpenedRole" class="mobile-btn rz-pop" style="background:#0066ff; border:2px solid #0044cc; display:none;">
    Compartilhar
  </button>
</div>
<script>
function attachOnboardingListeners() {
  if (window._onboardingListenersAttached) return;
  window._onboardingListenersAttached = true;
  const ob1 = document.getElementById("onboarding");
  const ob2 = document.getElementById("onboarding2");
  const ob3 = document.getElementById("onboarding3");
  // Next buttons
  document.getElementById("obNext1").addEventListener("click", () => {
    ob1.classList.add("rz-modal-hide");
    ob1.classList.remove("rz-open");
    setTimeout(()=>{ ob1.style.display="none"; ob1.classList.remove("rz-modal-hide"); },380);
    ob2.style.display = "block";
    ob2.classList.add("rz-open");
  });
  document.getElementById("obNext2").addEventListener("click", () => {
    ob2.classList.add("rz-modal-hide");
    ob2.classList.remove("rz-open");
    setTimeout(()=>{ ob2.style.display="none"; ob2.classList.remove("rz-modal-hide"); },380);
    ob3.style.display = "block";
    ob3.classList.add("rz-open");
  });
  // Finish onboarding with validation
  document.getElementById("finishOnboarding").addEventListener("click", () => {
    const name = document.getElementById("onName").value.trim();
    const user = document.getElementById("onUser").value.trim();
    const phone = document.getElementById("onPhone").value.trim();
    const email = document.getElementById("onEmail").value.trim();
    if (!name || !user) { alert("Preencha nome e username."); return; }
    // Extra strict validation
    if (!/^\S+@\S+\.\S+$/.test(email)) { alert("Email inválido."); return; }
    if (!/^[0-9+\-\s]{6,}$/.test(phone)) { alert("Telefone inválido."); return; }
    localStorage.setItem("profileName", name);
    localStorage.setItem("profileUser", user);
    localStorage.setItem("profilePhone", phone);
    localStorage.setItem("profileEmail", email);
    document.getElementById("bottomBar").style.display = "flex";
    ob3.classList.add("rz-modal-hide");
    ob3.classList.remove("rz-open");
    setTimeout(()=>{ ob3.style.display="none"; ob3.classList.remove("rz-modal-hide"); },380);
    document.getElementById("bottomBar").style.display = "flex";
    localStorage.setItem("onboardingDone", "1");
  });
  // Skip buttons
  document.querySelectorAll("#onboarding .skipOnboarding, #onboarding2 .skipOnboarding, #onboarding3 .skipOnboarding").forEach(btn => {
    btn.addEventListener("click", () => {
      ob1.classList.add("rz-modal-hide");
      ob1.classList.remove("rz-open");
      setTimeout(()=>{ ob1.style.display="none"; ob1.classList.remove("rz-modal-hide"); },380);
      ob2.classList.add("rz-modal-hide");
      ob2.classList.remove("rz-open");
      setTimeout(()=>{ ob2.style.display="none"; ob2.classList.remove("rz-modal-hide"); },380);
      ob3.classList.add("rz-modal-hide");
      ob3.classList.remove("rz-open");
      setTimeout(()=>{ ob3.style.display="none"; ob3.classList.remove("rz-modal-hide"); },380);
      document.getElementById("bottomBar").style.display = "flex";
      localStorage.setItem("onboardingDone", "1");
    });
  });
}
// Utility: disable/enable map interactions when native picker is open
function disableMapInteraction() {
  try {
    if (map && map.dragging) map.dragging.disable();
    if (map && map.scrollWheelZoom) map.scrollWheelZoom.disable();
    if (map && map.touchZoom) map.touchZoom.disable();
    if (map && map.doubleClickZoom) map.doubleClickZoom.disable();
    if (map && map.boxZoom) map.boxZoom.disable();
  } catch(e){ /* map may not be ready yet */ }
}
function enableMapInteraction() {
  try {
    if (map && map.dragging) map.dragging.enable();
    if (map && map.scrollWheelZoom) map.scrollWheelZoom.enable();
    if (map && map.touchZoom) map.touchZoom.enable();
    if (map && map.doubleClickZoom) map.doubleClickZoom.enable();
    if (map && map.boxZoom) map.boxZoom.enable();
  } catch(e){ }
}

let _pickerOpenFlag = false;
let _pickerLock = false;
function preOpenPicker() {
  _pickerOpenFlag = true;
  document.body.classList.add('no-scroll');
  disableMapInteraction();
  _pickerLock = true;
  document.body.style.pointerEvents = "none";

  // create an overlay to absorb touch/click events
  if (!document.getElementById('pickerOverlay')) {
    const ov = document.createElement('div');
    ov.id = 'pickerOverlay';
    ov.style.position = 'fixed';
    ov.style.inset = '0';
    ov.style.zIndex = '1000002';
    ov.style.background = 'rgba(0,0,0,0)';
    ov.style.pointerEvents = 'auto';
    ov.addEventListener('touchstart', e => e.stopPropagation(), { passive: false });
    ov.addEventListener('click', e => e.stopPropagation());
    document.body.appendChild(ov);
  }

  // install temporary global touch handlers while picker is open (stored so we can remove later)
  window._pickerTouchMoveHandler = function(e) {
    if (_pickerOpenFlag || _pickerLock) {
      e.preventDefault();
      e.stopPropagation();
    }
  };
  window._pickerTouchStartHandler = function(e) {
    if (_pickerOpenFlag || _pickerLock) {
      e.stopPropagation();
      e.preventDefault();
    }
  };

  document.addEventListener('touchmove', window._pickerTouchMoveHandler, { passive: false });
  document.addEventListener('touchstart', window._pickerTouchStartHandler, { passive: false });
}
function postClosePicker() {
  _pickerOpenFlag = false;
  _pickerLock = false;

  // ensure pointer-events are restored after a tiny delay to avoid flicker
  setTimeout(() => { document.body.style.pointerEvents = "auto"; }, 120);
  document.body.classList.remove('no-scroll');
  enableMapInteraction();

  // remove overlay
  const ov = document.getElementById('pickerOverlay');
  if (ov) {
    try { ov.removeEventListener('touchstart', (e) => {}); } catch(e){}
    try { ov.removeEventListener('click', (e) => {}); } catch(e){}
    ov.remove();
  }

  // remove temporary global touch handlers
  try {
    if (window._pickerTouchMoveHandler) document.removeEventListener('touchmove', window._pickerTouchMoveHandler, { passive: false });
  } catch(e){}
  try {
    if (window._pickerTouchStartHandler) document.removeEventListener('touchstart', window._pickerTouchStartHandler, { passive: false });
  } catch(e){}
  window._pickerTouchMoveHandler = null;
  window._pickerTouchStartHandler = null;
}

// Hook upload UI: open native picker and manage iOS quirks
const uploadBtnEl = document.getElementById('uploadBtn');
const uploadOverlayEl = document.getElementById('uploadOverlay');
const uploadEl = document.getElementById('upload');

uploadBtnEl.addEventListener('click', () => {
  preOpenPicker();
  setTimeout(() => {
    if (!_pickerOpenFlag) return;
    uploadEl.click();
  }, 60);
});

uploadOverlayEl.addEventListener('change', (e) => {
  try {
    if (!e.target.files || e.target.files.length === 0) { uploadOverlayEl.value = ''; return; }
    // Transfer files robustly (some browsers block direct assignment)
    try {
      uploadEl.files = e.target.files;
    } catch (err) {
      const dt = new DataTransfer();
      Array.from(e.target.files).forEach(f => dt.items.add(f));
      uploadEl.files = dt.files;
    }
    // Dispatch change slightly after to avoid race with picker close
    setTimeout(() => {
      const ev = new Event('change', { bubbles: true });
      uploadEl.dispatchEvent(ev);
    }, 60);
  } finally {
    // clear overlay so the same file(s) can be selected again later
    try { uploadOverlayEl.value = ''; } catch(e){}
  }
});

// Main input change handler will run the upload flow; ensure picker protections are cleared afterwards
uploadEl.addEventListener('change', async (e) => {
  // prevent re-entrancy
  if (window._uploadProcessing) return;
  window._uploadProcessing = true;

  // close picker protections immediately for UI responsiveness; processing runs detached
  _pickerOpenFlag = false;
  setTimeout(() => { postClosePicker(); }, 120);

  const files = Array.from(e.target.files || []);
  if (!files.length) {
    window._uploadProcessing = false;
    return;
  }

  openProgressModal(files.length, "Analisando mídias…");
  let progress = 0;
  waypoints = [];
  processedMedia = [];
  orderedMedia = [];
  ignoredMedia = [];
  const bounds = [];

  // helper: timeout wrapper for video metadata
  const loadVideoMetadataWithTimeout = (file, t = 2500) => new Promise((resolve, reject) => {
    const video = document.createElement('video');
    const url = URL.createObjectURL(file);
    let settled = false;
    const cleanup = () => { try{ URL.revokeObjectURL(url); }catch(e){} video.src = ''; };
    const onLoaded = () => { if (settled) return; settled = true; cleanup(); resolve(video); };
    const onError = (err) => { if (settled) return; settled = true; cleanup(); reject(err || new Error('video metadata error')); };
    video.preload = 'metadata';
    video.onloadedmetadata = onLoaded;
    video.onerror = onError;
    video.src = url;
    setTimeout(() => { if (settled) return; settled = true; cleanup(); resolve(video); }, t);
  });

  // helper: exifr.parse with timeout
  const exifrParseWithTimeout = (file, t = 2200) => new Promise(async (resolve) => {
    let done = false;
    try {
      const timer = setTimeout(() => { if (done) return; done = true; resolve(null); }, t);
      const parsed = await window.exifr.parse(file).catch(() => null);
      if (done) return;
      done = true;
      clearTimeout(timer);
      resolve(parsed);
    } catch (err) { resolve(null); }
  });

  try {
    // clear existing markers before processing
    map.eachLayer(layer => { if (layer instanceof L.Marker) map.removeLayer(layer); });

    const saveBtn = document.getElementById("saveRoute");
    saveBtn.style.display = "inline-block";
    saveBtn.disabled = false;
    saveBtn.style.opacity = "1";
    saveBtn.style.pointerEvents = "auto";

    for (let file of files) {
      try {
        progress++;
        updateProgressModal(progress, files.length, "Lendo EXIF…");

        // Video metadata with safe timeout
        if (file.type.startsWith("video")) {
          await loadVideoMetadataWithTimeout(file, 2500).catch(() => {});
        }

        // EXIF: try lightweight gps first then parse with timeout
        let exif = null;
        try { exif = await window.exifr.gps(file); } catch(e){ exif = null; }
        if (!exif || !exif.latitude) {
          const full = await exifrParseWithTimeout(file, 2000);
          if (full) {
            if (full.GPSLatitude && full.GPSLongitude) exif = { latitude: full.GPSLatitude, longitude: full.GPSLongitude };
            const iso = full && (full['com.apple.quicktime.location.ISO6709'] || full['Location.ISO6709'] || full['GPSCoordinates']);
            if ((!exif || !exif.latitude) && iso && typeof iso === 'string') {
              const m = iso.match(/([-+][0-9.]+)([-+][0-9.]+)/);
              if (m) exif = { latitude: parseFloat(m[1]), longitude: parseFloat(m[2]) };
            }
          }
        }

        if (!exif || !exif.latitude) exif = { latitude: null, longitude: null };

        // timestamp fallback interpolation
        if (exif.latitude === null || exif.longitude === null) {
          let bestMatch = null; let bestDiff = Infinity;
          waypoints.forEach(other => { if (!other.ts || !other.lat || !other.lon) return; const diff = Math.abs(new Date(other.ts).getTime() - new Date(file.lastModified).getTime()); if (diff < bestDiff) { bestDiff = diff; bestMatch = other; } });
          if (bestMatch && bestDiff <= 60000) { exif.latitude = bestMatch.lat; exif.longitude = bestMatch.lon; }
        }

        // Strict GPS policy: reject if still missing
        if (!exif || exif.latitude === null || exif.longitude === null) {
          ignoredMedia.push({ name: file.name, type: file.type });
          showToast("Ignorado (sem GPS): " + file.name, 2500);
          continue;
        }

        // read data URL with fallback
        const rawURL = await new Promise((resolve) => {
          const reader = new FileReader();
          let tried = false;
          reader.onload = () => { if (!reader.result && !tried) { tried = true; const r2 = new FileReader(); r2.onload = () => resolve(r2.result); r2.readAsDataURL(file); return; } resolve(reader.result); };
          reader.onerror = () => { resolve(null); };
          try { reader.readAsDataURL(file); } catch(e) { resolve(null); }
        });
        if (!rawURL) { ignoredMedia.push({ name: file.name, type: file.type }); showToast('Arquivo corrompido: ' + file.name); continue; }

        updateProgressModal(progress, files.length, "Compactando mídia…");
        const url = await compressImage(rawURL);

        // push waypoint + marker
        const isInterpolated = false;
        const ts = file.lastModified || Date.now();
        const mediaItem = { lat: exif.latitude, lon: exif.longitude, name: file.name, preview: url, url: url, type: file.type.startsWith('video') ? 'video' : 'image', isInterpolated, ts };
        processedMedia.push(mediaItem);
        orderedMedia.push(mediaItem);

        waypoints.push({ lat: exif.latitude, lon: exif.longitude, name: file.name, thumbnail: url, isVideo: file.type.startsWith('video'), isInterpolated, ts });

        const marker = L.marker([exif.latitude, exif.longitude]).addTo(map);
        markers.push(marker);
        const mediaHTML = file.type.startsWith('video') ? `<div class="popup-media-wrapper"><video src="${url}" class="popup-media" autoplay loop muted playsinline></video></div>` : `<div class="popup-media-wrapper"><img src="${url}" class="popup-media" /></div>`;
        const popupHTML = `<div style="text-align:center; max-width:220px;"><b>${file.name}</b><br>${mediaHTML}<br><div style="display:flex;justify-content:center;gap:10px;margin-top:8px;"><button class=\"popup-nav-btn\" onclick=\"event.stopPropagation(); focusMarker(${markers.length-2});\" style=\"padding:10px 14px; font-size:18px; border-radius:10px;\">⬅️</button><button class=\"popup-nav-btn\" onclick=\"event.stopPropagation(); focusMarker(${markers.length});\" style=\"padding:10px 14px; font-size:18px; border-radius:10px;\">➡️</button></div></div>`;
        marker.bindPopup(popupHTML);
        marker.on('popupopen', () => { setTimeout(() => smartPopupPosition(marker), 60); });

        bounds.push([exif.latitude, exif.longitude]);

      } catch (fileErr) {
        console.error('error processing file', fileErr);
        ignoredMedia.push({ name: file.name, type: file.type });
        showToast('Erro processando: ' + file.name, 2800);
        continue;
      }
    }

    // finish
    // Render thumbnails
    const sortableThumbnails = document.getElementById('sortableThumbnails');
    sortableThumbnails.innerHTML = '';
    orderedMedia.forEach((item, index) => {
      const thumb = document.createElement('img');
      thumb.src = item.preview;
      thumb.style.width = '70px'; thumb.style.height = '70px'; thumb.style.borderRadius = '10px'; thumb.style.objectFit = 'cover';
      thumb.setAttribute('data-index', index);
      thumb.setAttribute('draggable', 'true');
      sortableThumbnails.appendChild(thumb);
    });
    enableSorting();

    // Open reorder modal
    openReorderModal(waypoints, bounds);

    if (ignoredMedia && ignoredMedia.length) showToast(ignoredMedia.length + ' mídia(s) ignorada(s) por falta de GPS', 3500);

  } catch (err) {
    console.error('fatal upload handler error', err);
    showToast('Erro no upload. Veja console.');
  } finally {
    closeProgressModal();
    // clear file inputs so user can reselect same files
    try { uploadEl.value = ''; uploadOverlayEl.value = ''; } catch(e){}
    window._uploadProcessing = false;
    // ensure picker protections removed
    postClosePicker();
  }
});

// Consolidated picker-close detector: unify focus/visibility/pageshow into a single safe handler
function schedulePickerCloseCheck() {
  if (!_pickerOpenFlag) return;
  clearTimeout(window._pickerCloseTimeout);
  window._pickerCloseTimeout = setTimeout(() => {
    if (_pickerOpenFlag) postClosePicker();
  }, 180);
}

// If user cancels the native picker, Safari may not fire change — use a consolidated detector
window.addEventListener('focus', () => schedulePickerCloseCheck());
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') schedulePickerCloseCheck();
});
window.addEventListener('pageshow', () => schedulePickerCloseCheck());

// iOS Safari picker opening fix (keep for compatibility fallback)
uploadEl.addEventListener('click', () => {
  setTimeout(() => {}, 150);
});
</script>

<!-- TOAST CONTAINER -->
<div id="toastContainer" style="
  position: fixed;
  top: calc(env(safe-area-inset-top) + 12px);
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999999;
  display: flex;
  flex-direction: column;
  gap: 12px;
  width: calc(100% - 40px);
  max-width: 380px;
  padding: 0 20px;
  pointer-events: none;
"></div>
<script>
function showLoader(text){
  const g = document.getElementById('globalLoader');
  const t = document.getElementById('globalLoaderText');
  if (t) t.textContent = text || 'Processando...';
  if (g) g.style.display = 'flex';
}
function hideLoader(){
  const g = document.getElementById('globalLoader');
  if (g) g.style.display = 'none';
}
function showToast(msg, duration=3500){
  const c = document.getElementById('toastContainer');
  if (!c) return; 
  const el = document.createElement('div');
  el.style.pointerEvents = 'auto';
  el.style.background = 'rgba(30,30,30,0.96)';
  el.style.color = 'white';
  el.style.padding = '10px 14px';
  el.style.borderRadius = '10px';
  el.style.boxShadow = '0 8px 30px rgba(0,0,0,0.6)';
  el.style.fontSize = '14px';
  el.style.textAlign = 'center';
  el.style.opacity = '1';
  el.textContent = msg;
  c.appendChild(el);
  setTimeout(()=>{ el.style.transition = 'opacity 280ms'; el.style.opacity = '0'; setTimeout(()=>el.remove(),300); }, duration);
}
// replace built-in alert with toast for nicer UX
window.alert = function(msg){ showToast(String(msg)); };
</script>

<div id="map"></div>

<!-- Thumbnails container for sortable thumbnails -->
<div id="sortableThumbnails" style="display:flex; gap:10px; overflow-x:auto; padding:10px;"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/exifr/dist/lite.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<script>

let processedMedia = [];
let orderedMedia = [];
let ignoredMedia = [];
// --- IMAGE COMPRESSION FUNCTION ---
async function compressImage(dataUrl, maxSize = 300) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      resolve(canvas.toDataURL("image/jpeg", 0.7));
    };
    img.src = dataUrl;
  });
}

document.addEventListener("DOMContentLoaded", () => {
  // --- AUTOLOAD DE ROLÊ VIA LINK COMPARTILHADO ---
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.has("role")) {
    try {
      const decoded = JSON.parse(LZString.decompressFromEncodedURIComponent(urlParams.get("role")));

      // Show shared meta box if available
      const metaBox = document.getElementById("sharedMeta");
      if (decoded.creator) {
        metaBox.innerHTML =
          `<b>Criado por:</b> ${decoded.creator}<br>` +
          `<b>Data:</b> ${new Date(decoded.data).toLocaleString()}<br>` +
          `<b>Pontos no rolê:</b> ${decoded.totalPoints}`;
        metaBox.style.display = "block";
      }

      // limpar caminho atual
      waypoints = decoded.waypoints || [];
      markers = [];

      map.eachLayer(layer => {
        if (layer instanceof L.Marker || layer instanceof L.Polyline) map.removeLayer(layer);
      });

      const bounds = [];

      waypoints.forEach((wp, i) => {
        const marker = L.marker([wp.lat, wp.lon]).addTo(map);
        markers.push(marker);

        // Use unified popup-media-wrapper and popup-media class for both image and video
        const mediaHTML = wp.isVideo
          ? `<div class="popup-media-wrapper"><video src="${wp.thumbnail}" class="popup-media" autoplay loop muted playsinline></video></div>`
          : `<div class="popup-media-wrapper"><img src="${wp.thumbnail}" class="popup-media" /></div>`;

        marker.bindPopup(`
        <div style="text-align:center;">
          <b>${wp.name}</b><br>
          ${mediaHTML}<br>
          <button class="popup-nav-btn" onclick="event.stopPropagation(); focusMarker(${i - 1})" style="margin-right:10px; padding:18px 26px; font-size:24px; border-radius:12px;">⬅️</button>
          <button class="popup-nav-btn" onclick="event.stopPropagation(); focusMarker(${i + 1})" style="padding:18px 26px; font-size:24px; border-radius:12px;">➡️</button>
        </div>`);

        // --- Patch 3B: TopSafeFix (prevent popup clipping on top) ---
        {
          const popupEl = document.querySelector(".leaflet-popup");
          if (popupEl) {
            const rect = popupEl.getBoundingClientRect();
            const safeTop = (window.safeAreaInsetTop || 20);
            if (rect.top < safeTop + 40) {
              const p = marker.getLatLng();
              const shift = 0.0008;
              const newPos = L.latLng(p.lat - shift, p.lng);
              map.setView(newPos, map.getZoom(), { animate: false });
            }
          }
        }
        marker.on("popupopen", () => {
          setTimeout(() => { 
            const el = document.querySelector(".leaflet-popup");
            if (el) el.classList.add("rz-show");
          }, 10);
          {
            const bb = 110 + (window.safeAreaInsetBottom || 0) + (window.safeAreaInsetTop || 0);
            const p = marker.getLatLng();
            const c = map.project(p, map.getZoom());
            const nc = L.point(c.x, c.y - (bb + 40));
            const nl = map.unproject(nc, map.getZoom());
            map.setView(nl, map.getZoom(), { animate: true });
          }
          setTimeout(() => smartPopupPosition(marker), 50);
        });
        marker.on("popupclose", () => {
          const el = document.querySelector(".leaflet-popup");
          if (el) el.classList.remove("rz-show");
        });

        bounds.push([wp.lat, wp.lon]);
      });

      if (bounds.length > 0) {
        map.flyToBounds(bounds, { padding: [50,50], animate: true, duration: 0.7 });
      }

      if (window.currentRoute) { map.removeLayer(window.currentRoute); window.currentRoute = null; }
      let tempCoordsShared = null;
      if (waypoints.length > 1) tempCoordsShared = waypoints.map(w => [w.lat, w.lon]);
      map.once("moveend", () => {
        if (tempCoordsShared) {
          window.currentRoute = L.polyline(tempCoordsShared, {
            color: 'blue',
            weight: 3,
            fill: false,
            fillOpacity: 0,
            bubblingMouseEvents: false
          }).addTo(map);
        }
      });

      /* Rolê compartilhado carregado com sucesso. */
    } catch (e) {
      console.error("Erro carregando rolê compartilhado:", e);
    }
  }
  // --- FIM DO AUTOLOAD ---
  // localStorage onboardingDone try/catch
  try { localStorage.getItem("onboardingDone"); } catch(e) { localStorage.clear(); }
  const ob1 = document.getElementById("onboarding");
  const ob2 = document.getElementById("onboarding2");
  const ob3 = document.getElementById("onboarding3");

  if (!localStorage.getItem("onboardingDone")) {
    ob1.style.display = "flex";
    ob2.style.display = "none";
    ob3.style.display = "none";
  } else {
    ob1.style.display = "none";
    ob2.style.display = "none";
    ob3.style.display = "none";
  }
  // Defensive onboarding reset before listeners
  try {
    const t = localStorage.getItem("onboardingDone");
    if (t !== null && t !== "1") throw new Error("Corrupted onboarding flag");
  } catch(e) {
    localStorage.removeItem("onboardingDone");
  }
  attachOnboardingListeners();
  document.getElementById("bottomBar").style.display = localStorage.getItem("onboardingDone") ? "flex" : "none";
});

function loadRole(id) {
  window.currentOpenedRoleId = id;
  document.getElementById("shareOpenedRole").style.display = "inline-block";
  const saved = JSON.parse(localStorage.getItem("rolesSalvos") || "[]");
  const role = saved.find(r => r.id === id);
  if (!role) return;

  // Clear map markers and route
  map.eachLayer(layer => {
    if (layer instanceof L.Marker || layer instanceof L.Polyline) map.removeLayer(layer);
  });

  waypoints = role.waypoints;
  markers = [];

  const bounds = [];

  waypoints.forEach((wp, i) => {
    const marker = L.marker([wp.lat, wp.lon]).addTo(map);
    markers.push(marker);

    // Use unified popup-media-wrapper and popup-media class for both image and video
    const mediaHTML = wp.isVideo
      ? `<div class="popup-media-wrapper"><video src="${wp.thumbnail}" class="popup-media" autoplay loop muted playsinline></video></div>`
      : `<div class="popup-media-wrapper"><img src="${wp.thumbnail}" class="popup-media" /></div>`;

    marker.bindPopup(`
      <div style="text-align:center;">
        <b>${wp.name}</b><br>
        ${mediaHTML}<br>
        <button class="popup-nav-btn" onclick="event.stopPropagation(); focusMarker(${i - 1})" style="margin-right:10px; padding:18px 26px; font-size:24px; border-radius:12px;">⬅️</button>
        <button class="popup-nav-btn" onclick="event.stopPropagation(); focusMarker(${i + 1})" style="padding:18px 26px; font-size:24px; border-radius:12px;">➡️</button>
      </div>
    `);
    // --- Patch 3B: TopSafeFix (prevent popup clipping on top) ---
    {
      const popupEl = document.querySelector(".leaflet-popup");
      if (popupEl) {
        const rect = popupEl.getBoundingClientRect();
        const safeTop = (window.safeAreaInsetTop || 20);
        if (rect.top < safeTop + 40) {
          const p = marker.getLatLng();
          const shift = 0.0008;
          const newPos = L.latLng(p.lat - shift, p.lng);
          map.setView(newPos, map.getZoom(), { animate: false });
        }
      }
    }
    marker.on("popupopen", () => {
      setTimeout(() => { 
        const el = document.querySelector(".leaflet-popup");
        if (el) el.classList.add("rz-show");
      }, 10);
      {
        const bb = 110 + (window.safeAreaInsetBottom || 0) + (window.safeAreaInsetTop || 0);
        const p = marker.getLatLng();
        const c = map.project(p, map.getZoom());
        const nc = L.point(c.x, c.y - (bb + 40));
        const nl = map.unproject(nc, map.getZoom());
        map.setView(nl, map.getZoom(), { animate: true });
      }
      setTimeout(() => smartPopupPosition(marker), 50);
    });
    marker.on("popupclose", () => {
      const el = document.querySelector(".leaflet-popup");
      if (el) el.classList.remove("rz-show");
    });
    marker.on("click", () => {
      map.setView(marker.getLatLng(), map.getZoom(), { animate: true });
    });

    bounds.push([wp.lat, wp.lon]);
  });

  if (bounds.length > 0) {
    map.flyToBounds(bounds, { padding: [50,50], animate: true, duration: 0.7 });
  }

  if (window.currentRoute) { map.removeLayer(window.currentRoute); window.currentRoute = null; }
  let tempCoordsLoad = null;
  if (waypoints.length > 1) tempCoordsLoad = waypoints.map(wp => [wp.lat, wp.lon]);
  map.once("moveend", () => {
    if (tempCoordsLoad) {
      window.currentRoute = L.polyline(tempCoordsLoad, {
        color: 'blue',
        weight: 3,
        fill: false,
        fillOpacity: 0,
        bubblingMouseEvents: false
      }).addTo(map);
    }
  });
}

const map = L.map('map').setView([0,0], 2);

let _autoHideTimer = null;
let _barScrollLock = false;

function hideBottomBar() {}

function showBottomBar() {
  const bb = document.getElementById("bottomBar");
  if (!bb) return;
  window.requestAnimationFrame(() => {
    bb.classList.remove("bottom-hidden");
  });
}

map.on("movestart", () => {});

map.on("moveend", () => {});

L.tileLayer('https://basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', {
  attribution: '© CARTO © OpenStreetMap',
  detectRetina: false
}).addTo(map);

let waypoints = [];
let markers = [];

function focusMarker(index) {
  if (!markers.length) return;
  const total = markers.length;
  const i = ((index % total) + total) % total;
  const m = markers[i];
  const pos = m.getLatLng();
  map.setView(pos, 16, { animate: true });
  map.once('moveend', () => {
    try { m.openPopup(); } catch(e){}
  });
  setTimeout(() => {
    try { m.openPopup(); } catch(e){}
  }, 350);
}

// Progress Modal Functions
function openProgressModal(total = 1, msg = "Processando…") {
  const m = document.getElementById("progressModal");
  const bar = document.getElementById("progressModalBar");
  const txt = document.getElementById("progressModalMsg");
  const pct = document.getElementById("progressModalPercent");

  m.style.display = "flex";
  m.classList.remove("rz-modal-hide");

  // allow render cycle before animation
  setTimeout(() => {
    m.classList.add("rz-open");
  }, 20);
  bar.style.width = "0%";
  pct.textContent = "0%";
  txt.textContent = msg;

  window._progressTotal = total;
  window._progressCurrent = 0;
}

function updateProgressModal(current, total, msg) {
  const bar = document.getElementById("progressModalBar");
  const txt = document.getElementById("progressModalMsg");
  const pct = document.getElementById("progressModalPercent");

  const percentage = Math.min(100, Math.round((current / total) * 100));
  bar.style.width = percentage + "%";
  pct.textContent = percentage + "%";

  if (msg) txt.textContent = msg;
}

function closeProgressModal() {
  const m = document.getElementById("progressModal");
  if (!m) return;

  // smooth close animation
  m.classList.remove("rz-open");
  m.classList.add("rz-modal-hide");

  // wait for animation to finish
  setTimeout(() => {
    m.style.display = "none";
    m.classList.remove("rz-modal-hide");
  }, 380);
}

// (handled above with 150ms setTimeout for iOS Safari picker opening fix)
/* Duplicate upload handler removed — unified upload handler (with robust picker protections) is defined earlier as uploadEl.addEventListener('change', ...) */
function renderWaypointsAndRoute(waypointsToRender, boundsArray) {
  // clear previous markers
  markers = [];
  map.eachLayer(layer => {
    if (layer instanceof L.Marker || layer instanceof L.Polyline) map.removeLayer(layer);
  });

  const newBounds = [];
  // Use orderedMedia instead of processedMedia
  let items = orderedMedia.length > 0 ? orderedMedia : waypointsToRender;
  let i = 0;
  for (let item of items) {
    const marker = L.marker([item.lat, item.lon]).addTo(map);
    markers.push(marker);

    let mediaHTML = item.type === "video"
      ? `<div class="popup-media-wrapper"><video src="${item.url}" class="popup-media" autoplay loop muted playsinline></video></div>`
      : `<div class="popup-media-wrapper"><img src="${item.url}" class="popup-media" /></div>`;

    const popupHTML = `
      <div style="text-align:center; max-width:260px;">
        <b>${item.name}</b><br>
        ${mediaHTML}<br>
        <div style="display:flex; justify-content:center; gap:10px; margin-top:8px;">
          <button class="popup-nav-btn" onclick="event.stopPropagation(); focusMarker(${i - 1});"
            aria-label="Anterior" style="padding:10px 14px; font-size:18px; border-radius:10px;">
            ⬅️
          </button>
          <button class="popup-nav-btn" onclick="event.stopPropagation(); focusMarker(${i + 1});"
            aria-label="Próximo" style="padding:10px 14px; font-size:18px; border-radius:10px;">
            ➡️
          </button>
        </div>
      </div>
    `;

    marker.bindPopup(popupHTML);
    // --- Patch 3B: TopSafeFix (prevent popup clipping on top) ---
    {
      const popupEl = document.querySelector(".leaflet-popup");
      if (popupEl) {
        const rect = popupEl.getBoundingClientRect();
        const safeTop = (window.safeAreaInsetTop || 20);
        if (rect.top < safeTop + 40) {
          const p = marker.getLatLng();
          const shift = 0.0008;
          const newPos = L.latLng(p.lat - shift, p.lng);
          map.setView(newPos, map.getZoom(), { animate: false });
        }
      }
    }
    marker.on("popupopen", () => {
      setTimeout(() => { 
        const el = document.querySelector(".leaflet-popup");
        if (el) el.classList.add("rz-show");
      }, 10);
      {
        const bb = 110 + (window.safeAreaInsetBottom || 0) + (window.safeAreaInsetTop || 0);
        const p = marker.getLatLng();
        const c = map.project(p, map.getZoom());
        const nc = L.point(c.x, c.y - (bb + 40));
        const nl = map.unproject(nc, map.getZoom());
        map.setView(nl, map.getZoom(), { animate: true });
      }
      setTimeout(() => smartPopupPosition(marker), 50);
    });
    marker.on("popupclose", () => {
      const el = document.querySelector(".leaflet-popup");
      if (el) el.classList.remove("rz-show");
    });
    marker.on("click", () => {
      map.setView(marker.getLatLng(), map.getZoom(), { animate: true });
    });

    newBounds.push([item.lat, item.lon]);
    i++;
  }

  // draw route after user-centered flyToBounds finishes
  if (window.currentRoute) { map.removeLayer(window.currentRoute); window.currentRoute = null; }
  let tempRouteCoords = null;
  if (items.length > 1) tempRouteCoords = items.map(wp => [wp.lat, wp.lon]);

  map.once("moveend", () => {
    if (tempRouteCoords) {
      window.currentRoute = L.polyline(tempRouteCoords, {
        color: "blue",
        weight: 3,
        fill: false,
        fillOpacity: 0,
        bubblingMouseEvents: false
      }).addTo(map);
    }
  });

  if (newBounds.length > 0) {
    map.flyToBounds(newBounds, { padding: [50,50], animate: true, duration: 0.7 });
  }
}
// SortableJS-like drag-and-drop for thumbnails
function enableSorting() {
  const sortableThumbnails = document.getElementById("sortableThumbnails");
  if (!sortableThumbnails) return;
  let dragged = null;

  // detach previous listeners safely
  sortableThumbnails.querySelectorAll('img').forEach(img => {
    img.ondragstart = null;
    img.ondragend = null;
  });

  sortableThumbnails.addEventListener("dragstart", (e) => {
    const t = e.target;
    if (t && t.tagName === "IMG") {
      dragged = t;
      t.style.opacity = ".5";
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', t.getAttribute('data-index'));
    }
  });

  sortableThumbnails.addEventListener("dragend", (e) => {
    if (dragged) dragged.style.opacity = "";
    dragged = null;
  });

  sortableThumbnails.addEventListener("dragover", (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    const afterElement = getDragAfterElement(sortableThumbnails, e.clientX);
    if (!dragged) return;
    if (afterElement == null) sortableThumbnails.appendChild(dragged);
    else sortableThumbnails.insertBefore(dragged, afterElement);
  });

  sortableThumbnails.addEventListener("drop", (e) => {
    e.preventDefault();
    updateOrderFromDOM();
  });

  let touchDragging = null;
  sortableThumbnails.addEventListener('touchstart', (e) => {
    const t = e.target;
    if (t && t.tagName === "IMG") {
      touchDragging = t;
      t.classList.add('dragging-temp');
      t.style.opacity = '.5';
    }
  }, { passive: true });

  sortableThumbnails.addEventListener('touchend', () => {
    if (touchDragging) {
      touchDragging.classList.remove('dragging-temp');
      touchDragging.style.opacity = '';
      touchDragging = null;
      updateOrderFromDOM();
    }
  });

  function getDragAfterElement(container, x) {
    const draggableElements = [...container.querySelectorAll('img:not(.dragging-temp)')];
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = x - box.left - box.width / 2;
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else return closest;
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }
}


function updateOrderFromDOM() {
  if (window._reorderLock) return;
  window._reorderLock = true;

  try {
    const sortableThumbnails = document.getElementById("sortableThumbnails");
    if (!sortableThumbnails) return;

    const images = [...sortableThumbnails.children].filter(n => n.tagName === "IMG");

    const newOrdered = [];
    images.forEach((img, idx) => {
      const dataIdx = parseInt(img.getAttribute('data-index'));
      let src = processedMedia[dataIdx];
      if (!src) {
        const candidate = processedMedia.find(p => p.preview === img.src || p.url === img.src);
        src = candidate || { name: img.alt || ("mídia-" + idx), preview: img.src, url: img.src, lat: null, lon: null, type: "image" };
      }
      newOrdered.push({ ...src });
      img.setAttribute('data-index', idx);
    });

    orderedMedia = normalizeMediaObjects(newOrdered);

    waypoints = orderedMedia.map(item => ({
      lat: item.lat,
      lon: item.lon,
      name: item.name,
      thumbnail: item.preview || item.url,
      isVideo: item.isVideo,
      ts: item.ts,
      isInterpolated: item.isInterpolated
    }));

    const matched = [];
    orderedMedia.forEach((om, i) => {
      const matchIndex = processedMedia.findIndex(pm =>
        (pm.preview && pm.preview === om.preview) ||
        (pm.url && pm.url === om.url) ||
        (pm.name === om.name && pm.ts === om.ts)
      );
      matched[i] = matchIndex !== -1 ? { ...processedMedia[matchIndex] } : { ...om };
    });
    processedMedia = matched.map(it => ({ ...it }));

    scheduleRebuildAllMediaState(40, { preserveSelectedOrder: true });

  } catch (e) {
    console.error("updateOrderFromDOM error:", e);
  } finally {
    setTimeout(() => { window._reorderLock = false; }, 120);
  }
}

/* --- PATCH 5.3 — rebuildAllMediaState + scheduler --- */
let _rebuildScheduled = false;

function rebuildAllMediaState() {
  try {
    // Reconstruct orderedMedia from DOM
    const sortableThumbnails = document.getElementById("sortableThumbnails");
    if (!sortableThumbnails) return;

    const imgs = [...sortableThumbnails.children];
    const newOrder = imgs.map(img => {
      const originalIndex = parseInt(img.getAttribute("data-index"));
      return processedMedia[originalIndex];
    });

    // If the new order contains undefined items, abort silently
    if (newOrder.some(n => !n)) {
      console.warn("Skipping rebuildAllMediaState due to undefined media.");
      return;
    }

    orderedMedia = [...newOrder];

    // Re-sync waypoints in the same order
    waypoints = orderedMedia.map(m => ({
      lat: m.lat,
      lon: m.lon,
      name: m.name,
      thumbnail: m.preview,
      isVideo: m.type === "video",
      ts: m.ts
    }));

    console.log("rebuildAllMediaState: fully synced");
  } catch (err) {
    console.error("rebuildAllMediaState ERROR:", err);
  }
}

function scheduleRebuildAllMediaState() {
  if (_rebuildScheduled) return;
  _rebuildScheduled = true;
  setTimeout(() => {
    _rebuildScheduled = false;
    rebuildAllMediaState();
  }, 50);
}


function openReorderModal(initialWaypoints = [], initialBounds = []) {
  const modal = document.getElementById('reorderModal');
  const list = document.getElementById('reorderList');
  if (!modal || !list) return;

  rebuildAllMediaState({ preserveSelectedOrder: true });

  const source = orderedMedia.map(it => ({ ...it }));
  list.innerHTML = '';

  source.forEach((item, idx) => {
    const el = document.createElement('div');
    el.className = 'reorder-item';
    el.draggable = true;
    el.dataset.idx = idx;
    el.style.display = 'flex';
    el.style.alignItems = 'center';
    el.style.background = '#0b0b0b';
    el.style.border = '1px solid #222';
    el.style.padding = '8px';
    el.style.borderRadius = '10px';
    el.style.gap = '12px';

    const thumb = document.createElement(item.isVideo ? 'video' : 'img');
    thumb.className = 'thumbnail';
    thumb.style.width = '96px';
    thumb.style.height = '96px';
    thumb.style.objectFit = 'cover';
    thumb.src = item.preview || item.url || '';
    if (item.isVideo) {
      thumb.autoplay = true;
      thumb.loop = true;
      thumb.muted = true;
      thumb.playsInline = true;
    }

    const meta = document.createElement('div');
    meta.style.flex = '1';
    meta.innerHTML = `
      <div style="font-size:14px">${item.name}</div>
      <div style="font-size:12px; opacity:0.7">${item.ts ? new Date(item.ts).toLocaleString() : ''}</div>
    `;

    el.appendChild(thumb);
    el.appendChild(meta);
    list.appendChild(el);

    el.addEventListener('dragstart', (ev) => {
      ev.dataTransfer.setData('text/plain', el.dataset.idx);
      ev.dataTransfer.effectAllowed = 'move';
      el.classList.add('dragging-temp');
    });

    el.addEventListener('dragend', () => {
      el.classList.remove('dragging-temp');
    });

    el.addEventListener('dragover', (ev) => ev.preventDefault());
    el.addEventListener('drop', (ev) => {
      ev.preventDefault();
      const from = parseInt(ev.dataTransfer.getData('text/plain'));
      const toEl = ev.target.closest('.reorder-item');
      if (!toEl) return;
      const to = parseInt(toEl.dataset.idx);
      if (from === to) return;

      const children = [...list.children];
      const fromNode = children[from];
      const toNode = children[to];

      if (from < to) toNode.after(fromNode);
      else toNode.before(fromNode);

      [...list.children].forEach((c, i) => c.dataset.idx = i);
    });
  });

  modal.style.display = 'block';
  modal.classList.add("rz-open");

  document.getElementById('reorderConfirm').onclick = () => {
    const newOrder = [...list.children].map(c => {
      const idx = parseInt(c.dataset.idx);
      return source[idx];
    });

    orderedMedia = newOrder.map(it => ({ ...it }));
    processedMedia = orderedMedia.map(it => ({ ...it }));
    waypoints = orderedMedia.map(item => ({
      lat: item.lat,
      lon: item.lon,
      name: item.name,
      thumbnail: item.preview || item.url,
      isVideo: item.isVideo,
      ts: item.ts,
      isInterpolated: item.isInterpolated
    }));

    modal.classList.add("rz-modal-hide");
    modal.classList.remove("rz-open");
    setTimeout(() => {
      modal.style.display = "none";
      modal.classList.remove("rz-modal-hide");
    }, 380);
    renderWaypointsAndRoute(waypoints, []);
  };

  document.getElementById('reorderCancel').onclick = () => {
    modal.classList.add("rz-modal-hide");
    modal.classList.remove("rz-open");
    setTimeout(() => {
      modal.style.display = "none";
      modal.classList.remove("rz-modal-hide");
    }, 380);
    renderWaypointsAndRoute(initialWaypoints, initialBounds);
  };
}

// Salvar rota no localStorage
document.getElementById('saveRoute').addEventListener('click', () => {
  try {
    if (!waypoints || !waypoints.length) {
      alert("Nenhum rolê para salvar.");
      return;
    }

    const title = prompt("Dê um título ao seu rolê:");
    if (!title) {
      alert("Título obrigatório.");
      return;
    }

    const saved = JSON.parse(localStorage.getItem("rolesSalvos") || "[]");

    const role = {
      id: Date.now(),
      titulo: title,
      data: new Date().toISOString(),
      waypoints: waypoints.map(wp => ({
        lat: wp.lat ?? null,
        lon: wp.lon ?? null,
        name: wp.name || "",
        thumbnail: wp.thumbnailCompressed || wp.thumbnail || null,
        isVideo: !!wp.isVideo,
        ts: wp.ts || null
      }))
    };

    saved.push(role);
    localStorage.setItem("rolesSalvos", JSON.stringify(saved));

    alert("Rolê salvo com sucesso!");

    // disable button until new media uploaded
    const saveBtn = document.getElementById("saveRoute");
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.style.opacity = "0.4";
      saveBtn.style.pointerEvents = "none";
    }

    // refresh profile list if modal open
    try { renderProfileRoles(); } catch(e) { }
  } catch (err) {
    console.error('Erro ao salvar rolê:', err);
    alert('Erro ao salvar rolê. Veja o console para mais detalhes.');
  }
});


// --- STORY EDITOR TYPE SHARE AURA ---
document.addEventListener("DOMContentLoaded", () => {
  const storyEditor = document.getElementById("storyEditor");
  const storyCanvas = document.getElementById("storyCanvas");

  if (!storyCanvas) {
    console.error("storyCanvas not found — story editor not initialized.");
    return;
  }

  const ctx = storyCanvas.getContext("2d");

  document.getElementById("closeStoryEditor").addEventListener("click", () => {
    storyEditor.style.display = "none";
  });

  document.getElementById("exportStory").addEventListener("click", () => {
    storyCanvas.toBlob(blob => saveAs(blob, "role-story.jpg"));
  });
});

function renderProfileRoles() {
  const saved = JSON.parse(localStorage.getItem("rolesSalvos") || "[]");
  document.getElementById("profileRoles").innerHTML = saved.map(r => `
    <div style="padding:12px; background:#111; border:1px solid #555; border-radius:10px; margin:10px 0; color:white;">
      <b>${r.titulo || ("Rolê " + r.id)}</b><br>
      <span style="font-size:14px; opacity:0.8;">${new Date(r.data).toLocaleString()}</span><br>

      <button onclick="document.getElementById('profileModal').style.display='none'; loadRole(${r.id});"
        style="margin-top:10px; padding:6px 10px; border-radius:6px; background:#333; color:white; border:1px solid:#666;">
        Abrir
      </button>

      <button onclick="editarRole(${r.id})"
        style="margin-top:10px; margin-left:10px; padding:6px 10px; border-radius:6px; background:#222; color:white; border:1px solid:#555;">
        Editar
      </button>

      <button onclick="compartilharRole(${r.id})"
        style="margin-top:10px; margin-left:10px; padding:6px 10px; border-radius:6px; background:#0066ff; color:white; border:1px solid:#0044cc;">
        Compartilhar
      </button>
    </div>
  `).join("");
}

document.getElementById("openProfile").addEventListener("click", () => {
  const m = document.getElementById("profileModal");
  document.getElementById("profileName").textContent = localStorage.getItem("profileName") || "—";
  document.getElementById("profileUser").textContent = localStorage.getItem("profileUser") || "—";
  document.getElementById("profilePhone").textContent = localStorage.getItem("profilePhone") || "—";
  document.getElementById("profileEmail").textContent = localStorage.getItem("profileEmail") || "—";
  const photo = localStorage.getItem("profilePhoto");
  const pp = document.getElementById("profilePhotoPreview");
  if (photo) { pp.src = photo; pp.style.display = "block"; } else { pp.style.display = "none"; }
  renderProfileRoles();
  m.style.display = "block";
  m.classList.add("rz-open");
  m.style.zIndex = "999999";
  // prevent page scroll and map interaction while profile is open
  document.body.classList.add("no-scroll");
  try { disableMapInteraction(); } catch(e) { /* ignore if map not ready */ }

  // prevent touches from bubbling to the map underneath (stops ghost clicks)
  m.addEventListener('touchstart', function _stopTouch(e){ e.stopPropagation(); }, { passive: false });
  m.addEventListener('click', function _stopClick(e){ e.stopPropagation(); });
});

document.getElementById("shareOpenedRole").addEventListener("click", () => {
  if (window.currentOpenedRoleId) {
    compartilharRole(window.currentOpenedRoleId);
  }
});

document.getElementById("closeProfile").addEventListener("click", () => {
  const modal = document.getElementById("profileModal");
  if (!modal) return;

  // add exit animation
  modal.classList.add("rz-modal-hide");
  modal.classList.remove("rz-open");

  // restore scroll & map interaction
  document.body.classList.remove("no-scroll");
  try { enableMapInteraction(); } catch(e){}

  // remove any picker overlay
  const pov = document.getElementById('pickerOverlay');
  if (pov) pov.remove();

  // wait for animation to finish, then fully hide modal
  setTimeout(() => {
    modal.style.display = "none";
    modal.classList.remove("rz-modal-hide");
  }, 400);
});

// Safety: prevent touch/click events from reaching the map when any modal is open
['profileModal','reorderModal','reorderModal','onboarding','onboarding2','onboarding3','storyEditor'].forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('touchstart', (e) => { if (el.style.display !== 'none') e.stopPropagation(); }, { passive: false });
  el.addEventListener('click', (e) => { if (el.style.display !== 'none') e.stopPropagation(); });
});

function compartilharRole(id) {
  const saved = JSON.parse(localStorage.getItem("rolesSalvos") || "[]");
  const role = saved.find(r => r.id === id);
  if (!role) return;

  const payload = {
    titulo: role.titulo,
    waypoints: role.waypoints,
    creator: localStorage.getItem("profileUser") || "Usuário",
    data: role.data,
    totalPoints: role.waypoints.length
  };

  const encoded = LZString.compressToEncodedURIComponent(JSON.stringify(payload));
  const shareURL = window.location.origin + window.location.pathname + "?role=" + encoded;

  navigator.clipboard.writeText(shareURL).then(() => {
    alert("Link do rolê copiado!");
  });
}

function editarRole(id) {
  const saved = JSON.parse(localStorage.getItem("rolesSalvos") || "[]");
  const roleIndex = saved.findIndex(r => r.id === id);
  if (roleIndex === -1) {
    alert("Rolê não encontrado.");
    return;
  }

  const novoTitulo = prompt("Editar título do rolê:", saved[roleIndex].titulo || "");
  if (!novoTitulo) return;

  saved[roleIndex].titulo = novoTitulo;
  localStorage.setItem("rolesSalvos", JSON.stringify(saved));

  try { renderProfileRoles(); } catch(e) {}
  alert("Título atualizado!");
}
// Foto de perfil
document.getElementById("profilePhotoInput").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  if (!file.type.startsWith("image/")) { alert("Envie apenas imagens para foto de perfil."); return; }
  const reader = new FileReader();
  reader.onload = () => {
    if (!reader.result) return;
    localStorage.setItem("profilePhoto", reader.result);
    const pp = document.getElementById("profilePhotoPreview");
    pp.src = reader.result;
    pp.style.display = "block";
  };
  reader.readAsDataURL(file);
});
// Make sure all popup-nav-btns always stop propagation
document.addEventListener("click", (e) => {
  if (e.target.classList && e.target.classList.contains("popup-nav-btn")) {
    e.stopPropagation();
  }
});
</script>

<div id="storyEditor" class="rz-modal" style="display:none; position:fixed; inset:0; background:black; z-index:9999; padding:20px;">
  <button id="closeStoryEditor" style="position:absolute; top:20px; right:20px; z-index:10000; padding:8px 14px;">Fechar</button>
  <div id="storyCanvasWrapper" style="width:100%; height:100%; display:flex; justify-content:center; align-items:center;">
    <canvas id="storyCanvas" width="1080" height="1920" style="background:black; border:2px solid #444;"></canvas>
  </div>
  <button id="exportStory" style="position:absolute; bottom:20px; left:50%; transform:translateX(-50%); padding:10px 18px;">Exportar Story</button>
</div>
<div id="sharedMeta" style="display:none; width:100%; padding:20px; background:#000; color:white; text-align:center; font-size:18px; line-height:1.5;"></div>
</body>
</html>
